;;; files-to-prompt.el --- Convert files to prompts for LLMs -*- lexical-binding: t -*-

;; Copyright (C) 2024 Jason Walsh

;; Author: Jason Walsh <j@wal.sh>
;; Version: 0.2
;; Package-Requires: ((emacs "27.1"))
;; Keywords: tools, ai, llm
;; URL: https://github.com/jwalsh/files-to-prompt-el

;;; Commentary:

;; This package provides functionality to convert files and directories
;; into prompts suitable for large language models (LLMs).

;;; Code:

(require 'org)
(require 'vc)

(defun files-to-prompt--filter-files (files)
  "Filter FILES to exclude binaries, dotfiles, and .gitignore entries."
  (let* ((default-directory (if (file-directory-p (car files))
                                (car files)
                              (file-name-directory (car files))))
         (gitignore-file (expand-file-name ".gitignore" default-directory))
         (gitignore-patterns
          (when (file-exists-p gitignore-file)
            (with-temp-buffer
              (insert-file-contents gitignore-file)
              (split-string (buffer-string) "\n" t)))))
    (cl-remove-if
     (lambda (file)
       (or (string-match-p "/\\." file)  ; Exclude dot directories
           (string-match-p "^\\." (file-name-nondirectory file))  ; Exclude dotfiles
           (string-match-p "\\.\\(exe\\|dll\\|so\\|dylib\\|bin\\|obj\\|elc\\)$" file)  ; Exclude common binary extensions
           (with-temp-buffer  ; Check if file is binary
             (set-buffer-multibyte nil)
             (insert-file-contents-literally file nil 0 1000)
             (goto-char (point-min))
             (re-search-forward "[^\000-\177]" nil t))
           (and gitignore-patterns  ; Check if file matches .gitignore patterns
                (let ((relative-path (file-relative-name file default-directory)))
                  (cl-some (lambda (pattern)
                             (string-match-p (wildcard-to-regexp 
                                              (string-trim pattern))
                                             relative-path))
                           gitignore-patterns)))))
     files)))

(defun files-to-prompt--format-default ()
  "Format buffer content in default style."
  (let ((formatted-content ""))
    (goto-char (point-min))
    (while (not (eobp))
      (let ((line (buffer-substring-no-properties 
                   (line-beginning-position) 
                   (line-end-position))))
        (if (string-prefix-p "File: " line)
            (setq formatted-content 
                  (concat formatted-content 
                          (unless (string-empty-p formatted-content) "\n\n")
                          line "\n"))
          (setq formatted-content 
                (concat formatted-content line "\n"))))
      (forward-line))
    formatted-content))

(defun files-to-prompt--format-cxml ()
  "Format buffer content in Claude XML-ish style."
  (goto-char (point-min))
  (let ((documents '())
        (current-document '())
        (current-file ""))
    (while (not (eobp))
      (let ((line (buffer-substring-no-properties (line-beginning-position) (line-end-position))))
        (if (string-prefix-p "File: " line)
            (progn
              (when current-document
                (push (nreverse current-document) documents)
                (setq current-document '()))
              (setq current-file (substring line 6)))
          (push (cons current-file line) current-document)))
      (forward-line 1))
    (when current-document
      (push (nreverse current-document) documents))
    (setq documents (nreverse documents))
    
    (erase-buffer)
    (insert "<documents>\n")
    (let ((index 1))
      (dolist (doc documents)
        (insert (format "  <document index=\"%d\">\n" index))
        (insert (format "    <source>%s</source>\n" (caar doc)))
        (insert "    <document_content>\n")
        (dolist (line (cdr doc))
          (insert (format "      %s\n" (files-to-prompt--xml-escape-string (cdr line)))))
        (insert "    </document_content>\n")
        (insert "  </document>\n")
        (setq index (1+ index))))
    (insert "</documents>\n")))

(defun files-to-prompt--xml-escape-string (string)
  "Escape XML special characters in STRING."
  (replace-regexp-in-string
   "&" "&amp;"
   (replace-regexp-in-string
    ">" "&gt;"
    (replace-regexp-in-string
     "<" "&lt;"
     (replace-regexp-in-string
      "'" "&apos;"
      (replace-regexp-in-string
       "\"" "&quot;"
       string))))))

(defun files-to-prompt--format-org (files project-root)
  "Format buffer content in org-mode style with tangle instructions.
FILES is the list of files to process.
PROJECT-ROOT is the root directory of the project."
  (let ((content ""))
    (setq content (concat content "#+TITLE: Files to Prompt Output\n"))
    (setq content (concat content "#+AUTHOR: Generated by files-to-prompt\n"))
    (setq content (concat content (format "#+DATE: %s\n\n" (format-time-string "[%Y-%m-%d %a]"))))
    (dolist (file files)
      (let* ((relative-path (file-relative-name file project-root))
             (file-ext (file-name-extension file))
             (lang (cond
                    ((string= file-ext "el") "emacs-lisp")
                    ((string= file-ext "org") "org")
                    (t file-ext))))
        (setq content (concat content (format "* %s\n" relative-path)))
        (setq content (concat content (format "#+BEGIN_SRC %s :tangle %s :mkdirp yes\n" lang relative-path)))
        (with-temp-buffer
          (insert-file-contents file)
          (goto-char (point-min))
          (while (not (eobp))
            (let ((line (buffer-substring-no-properties (line-beginning-position) (line-end-position))))
              (cond
               ;; Escape lines starting with #+
               ((string-prefix-p "#+" line)
                (setq content (concat content ",#+" (substring line 2) "\n")))
               ;; Escape lines starting with *
               ((string-prefix-p "*" line)
                (setq content (concat content ",*" (substring line 1) "\n")))
               ;; No change for other lines
               (t
                (setq content (concat content line "\n")))))
            (forward-line 1)))
        (setq content (concat content "#+END_SRC\n\n"))))
    content))


(defun files-to-prompt--get-project-root ()
  "Get the root directory of the current project."
  (or (vc-git-root default-directory)
      default-directory))

;;;###autoload
(defun files-to-prompt (&optional format)
  "Process files and generate a prompt based on FORMAT.
If FORMAT is nil or 'org', use org-mode format.
If FORMAT is 'txt', use default text format.
If FORMAT is 'cxml', use Claude XML-ish format.
If called interactively with no FORMAT, use the default org-mode format."
  (interactive)
  (let* ((project-root (files-to-prompt--get-project-root))
         (current-file (buffer-file-name))
         (files (if current-file
                    (list current-file)
                  (directory-files-recursively project-root "^[^.].*\\.[^.]+$")))
         (filtered-files (files-to-prompt--filter-files files))
         (format (or format 'org))
         (timestamp (format-time-string "%Y%m%d%H%M%S"))
         (output-dir (expand-file-name 
                      (format ".files-to-prompt-%s" timestamp)
                      project-root))
         (output-file (expand-file-name 
                       (format "output.%s" (symbol-name format))
                       output-dir))
         (max-tokens 1000))
    
    (make-directory output-dir t)
    
    (with-temp-buffer
      (dolist (file filtered-files)
        (insert (format "File: %s\n" file))
        (insert-file-contents-literally file)
        (goto-char (point-max))
        (insert "\n\n"))
      
      ;; Limit to max-tokens
      (goto-char (point-max))
      (forward-line (- max-tokens))
      (delete-region (point-min) (point))
      
      ;; Format based on the specified format
      (setq formatted-content
            (cond
             ((eq format 'org)
              (files-to-prompt--format-org filtered-files project-root))
             ((eq format 'cxml)
              (files-to-prompt--format-cxml)
              (buffer-string))
             (t  ; default txt format
              (files-to-prompt--format-default))))
      
      ;; Write to output file
      (with-temp-file output-file
        (insert formatted-content))
      (message "Generated %s prompt saved to: %s" (symbol-name format) output-file))))

(provide 'files-to-prompt)

;;; files-to-prompt.el ends here
